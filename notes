# Minitalk:

The purpose of this project is to code a small data change program using UNIX signals.

• Name your executable files client and server.
• You have to turn in a Makefile which will compile your source files. It must not
relink.
• You can definitely use your libft.
• You have to handle errors thoroughly. In no way your program should quit unexpectedly (segmentation fault, bus error, double free, and so forth).
• Your program mustn’t have memory leaks.
• You can have one global variable per program (one for the client and one for
the server), but you will have to justify their use.
• In order to complete the mandatory part, you are allowed to use the following functions:
  ◦ write
  ◦ ft_printf and any equivalent YOU coded ◦ signal
  ◦ sigemptyset
  ◦ sigaddset
  ◦ sigaction
  ◦ kill
  ◦ getpid
  ◦ malloc
  ◦ free
  ◦ pause
  ◦ sleep
  ◦ usleep
  ◦ exit


## Mandatory Part:

1. You must create a communication program in the form of a client and a server.
    • The server must be started first. After its launch, it has to print its PID.
    • The client takes two parameters: 
        ◦ The server PID.
        ◦ The string to send.

2. The client must send the string passed as a parameter to the server.

3. Once the string has been received, the server must print it.
    • The server has to display the string pretty quickly. Quickly means that if you think it takes too long, then it is probably too long.
    • Your server should be able to receive strings from several clients in a row without needing to restart.
    • The communication between your client and your server has to be done only using UNIX signals.
    • You can only use these two signals: SIGUSR1 and SIGUSR2.
         1 second for displaying 100 characters is way too much!

Note: 
Linux system does NOT queue signals when you already have pending signals of this type!  Bonus time?


## Bonus Part:

• The server acknowledges every message received by sending back a signal to the client.
• Unicode characters support!



## 1. What are UNIX signals?

UNIX SIGNALS:

- In Unix-like operating systems, signals are a form of inter-process communication (IPC) used to notify a process that a particular event has occurred. 
- Signals can be generated by the operating system or sent by one process to another. 
- They are used for various purposes, including process management, error handling, and communication between processes. 
- Signals can only transmit one bit at a time.
    - The limitation of transmitting only one bit at a time through signals is intentional with the purpose of being lightweight, efficient, and suitable for real-time event notification and simple inter-process communication.
    - While signals are suitable for lightweight communication and event notification, they are not the most efficient way to transmit large amounts of data between processes. For more data-intensive communication, other mechanisms like sockets, pipes, shared memory, and message queues are often used.

Here's a basic overview of how signals work and how you can use them in a client-server program:

Signal Basics:
- Signals are represented by integer values, such as 
    - SIGINT (2), 
    - SIGTERM (15), 
    - SIGUSR1 (10), and so on.
- The kill system call is commonly used to send signals to processes. 
    - The command kill -<signal> <pid> sends a signal to the specified process.


Handling Signals:
- In C, you can set up signal handlers using the signal() function or the more modern sigaction() function.
- A signal handler is a function that gets called when a specific signal is received. 
    - It allows your program to react to the signal.


Signal Handling in a Client-Server Program:
- In your client-server program, you can use signals to facilitate communication between the client and server processes. 
    - For instance, you could define a custom signal to indicate when the client wants to communicate with the server.


Here's a simple example of a client-server program using signals in C:
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void server_signal_handler(int signum) 
{
    // Handle server-specific signal
    if (signum == SIGUSR1) 
    {
        printf("Server received a signal from the client.\n");
    }
}

int main() 
{
    // Set up server signal handler
    signal(SIGUSR1, server_signal_handler);

    // Fork a child process for the client
    pid_t client_pid = fork();

    if (client_pid == 0) 
    {
        // This is the client process
        printf("Client process is running.\n");
        // Send a signal to the server process
        kill(getppid(), SIGUSR1);
    } 
    else if (client_pid > 0) 
    {
        // This is the server process
        printf("Server process is running.\n");
        // Wait for the signal from the client
        pause();
    } 
    else 
    {
        perror("fork");
        exit(1);
    }
    return (0);
}
```

### 1.1 Only SIGUSR1 and SIGUSR2 signals are permitted for use.

- SIGUSR1 and SIGUSR2 are two user-defined signals in Unix-like operating systems. 
- These signals are provided for application-specific purposes and are not assigned specific meanings by the operating system itself. Instead, they are available for programmers to use as needed to implement custom behavior or communication between processes. 
- These signals can be used to trigger custom actions in a program when specific events occur.

Here's a brief overview of SIGUSR1 and SIGUSR2:

SIGUSR1 (User-defined Signal 1):

Signal Number: 
- 10
Purpose: 
- SIGUSR1 is often used by user programs to indicate a specific event or request a particular action. 
- Since it's user-defined, its interpretation and handling depend on the application.
Example Use: 
- Imagine you have a long-running process that performs a certain task. You might use SIGUSR1 to instruct the process to save its current state or perform a specific operation, without the need to terminate the process.
- Or, a program might use SIGUSR1 to toggle a certain behavior, initiate a data transfer, or prompt a process to perform a certain task.


SIGUSR2 (User-defined Signal 2):

Signal Number: 
- 12
Purpose: 
- Similar to SIGUSR1, SIGUSR2 is a user-defined signal that can be used to convey a specific event or action.
Example Use: 
- Continuing from the previous example, you could use SIGUSR2 to trigger another type of action in the long-running process, perhaps to generate a report, handle communication, indicate a state change, or update its configuration.


- Both SIGUSR1 and SIGUSR2 provide a way for applications to communicate with their processes in a customized manner. 
- However, it's important to note that the exact behavior and handling of these signals depend on how they are implemented within the program's code.

- When sending or receiving these signals, you can use the kill system call or the kill command in the terminal, passing the appropriate signal number and the process ID (PID) of the target process.

Example usage from the command line:
```
# Send SIGUSR1 signal to process with PID 12345
kill -SIGUSR1 12345

# Send SIGUSR2 signal to process with PID 67890
kill -SIGUSR2 67890
```


## 2. What are these functions?

1. signal
2. sigemptyset
3. sigaddset
4. sigaction
5. kill
6. getpid
7. pause
8. sleep
9. usleep
10. exit

### 1. signal():

### 2. sigemptyset():
- is a function in C that is used to initialize an empty signal set. 
- The purpose of sigemptyset() is to create an empty set of signals, which can then be manipulated using other signal-related functions.

Syntax:
```
#include <signal.h>

int sigemptyset(sigset_t *set);
```

Parameters:
set: 
- A pointer to a sigset_t data structure that will be initialized as an empty signal set.

Return Value:
- The function returns 0 on success and -1 on error and sets errno to show that an error has occurred.

Usage:
- The primary use of sigemptyset() is to initialize a signal set (represented by the sigset_t data structure) to an empty state. 
    - This means that after calling this function, the signal set will not contain any signals.
- It prepares a signal set before adding or removing signals using other functions like sigaddset() and sigdelset(). 
- Signal sets are used in various signal-related functions, such as when configuring signal masks for blocking or unblocking signals, as well as for checking the presence of signals in a set.
- This function is typically used as the first step to build custom signal sets for further manipulation.

Example:
```
#include <stdio.h>
#include <signal.h>

int main() 
{
    sigset_t mySignalSet;

    // Initialize an empty signal set
    if (sigemptyset(&mySignalSet) == -1) 
    {
        perror("sigemptyset");
        return (1);
    }

    // Add a signal (e.g., SIGINT) to the set
    if (sigaddset(&mySignalSet, SIGINT) == -1) 
    {
        perror("sigaddset");
        return (1);
    }

    // Check if a specific signal is in the set
    if (sigismember(&mySignalSet, SIGINT)) 
    {
        printf("SIGINT is in the signal set.\n");
    } 
    else 
    {
        printf("SIGINT is not in the signal set.\n");
    }
    return (0);
}
```

- In this example, sigemptyset() is used to initialize an empty signal set named mySignalSet. 
- Then, the program adds the SIGINT signal to the set using sigaddset(). 
- Finally, it checks whether SIGINT is a member of the set using sigismember().


### 3. sigaddset():
-  is a function in C used to manipulate signal sets.
-  Signal sets are data objects that let a thread keep track of groups of signals. For example, a thread might create a signal set to record which signals it is blocking, and another signal set to record which signals are pending.
- In other words, signal sets are collections of signals that are grouped together. 

Syntax:
```
#include <signal.h>

int sigaddset(sigset_t *set, int signum);
```

Parameters:
sigset_t *set: 
- This is a pointer to the signal set wherein you want to add a new signal.

int signum: 
- This is the signal number that you want to add to the signal set. 
- The signals are defined in the signal.h header file as macros, they include SIGINT, SIGSTOP, SIGUSR1, etc.
- Each signal has a specific number associated with it.

Return Value:
- The function returns 0 on success and -1 on error and sets errno to show that an error has occurred.

Usage:
- The primary use of sigaddset() is used to add a specified signal to a specified signal set. 
- This can be useful when you want to customize how your program responds to different signals.

Example:
```
#include <stdio.h>
#include <signal.h>

int main() 
{
    sigset_t signalSet;
    
    // Initialize an empty signal set
    if (sigemptyset(&signalSet) == -1) 
    {
        perror("sigemptyset");
        return (1);
    }
    
    // Add SIGUSR1 signal to the signal set
    if (sigaddset(&signalSet, SIGUSR1) == -1) 
    {
        perror("sigaddset");
        return (1);
    }
    
    // Add SIGUSR2 signal to the signal set
    if (sigaddset(&signalSet, SIGUSR2) == -1) 
    {
        perror("sigaddset");
        return (1);
    }
    
    // Check if SIGUSR1 is in the signal set
    if (sigismember(&signalSet, SIGUSR1)) 
    {
        printf("SIGUSR1 is in the signal set.\n");
    }
    
    // Check if SIGUSR2 is in the signal set
    if (sigismember(&signalSet, SIGUSR2)) 
    {
        printf("SIGUSR2 is in the signal set.\n");
    }
    return (0);
}
```

In this example:
- we first initialize an empty signal set using sigemptyset(). 
- Then, we use sigaddset() to add the SIGUSR1 and SIGUSR2 signals to the set. 
- Finally, we use sigismember() to check if each signal is present in the set and print a message accordingly.


### 4. sigaction():
- is a function in C used to examine and set the action that should be taken when a specific signal occurs.

Syntax:
```
#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

Parameters:
signum: 
- This is the signal number. 
- Each signal has a specific number associated with it, such as SIGINT for the interrupt signal.

act: 
- This is a pointer to a struct sigaction which specifies the new action to take for the signum signal. 
- If this parameter is NULL, then the signal's disposition is not changed, but the current disposition can still be retrieved via the oldact parameter.

oldact: 
- This is a pointer to a struct sigaction where sigaction() saves the current action for the signum signal. 
- If this parameter is NULL, then the current disposition is not saved.

Return Value:
- The function returns 0 on success and -1 on error and sets errno to show that an error has occurred.

Usage:
- The sigaction() function allows the calling process to change its action for the signal `signum` to the action described by `act`. - `signum` specifies the signal and `act` specifies the new action to take. 
- A NULL act argument can be used to query the current action without changing it.

Example:
```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void signal_handler(int signum) 
{
    if (signum == SIGUSR1) 
    {
        printf("Received SIGUSR1 signal.\n");
    } 
    else if (signum == SIGUSR2) 
    {
        printf("Received SIGUSR2 signal.\n");
    }
}

int main() 
{
    struct sigaction sa;
    sa.sa_handler = signal_handler;
    sa.sa_flags = 0;

    if (sigaction(SIGUSR1, &sa, NULL) == -1) 
    {
        perror("Error setting up SIGUSR1 handler");
        return 1;
    }

    if (sigaction(SIGUSR2, &sa, NULL) == -1) 
    {
        perror("Error setting up SIGUSR2 handler");
        return 1;
    }

    printf("Waiting for signals...\n");
    while (1) 
    {
        // Do other tasks or simply wait here
    }
    return (0);
}
```

In this example:
- The sigaction() function is used to associate the customHandler() function with both SIGUSR1 and SIGUSR2 signals. 
- When these signals are received, the custom handler function is executed, providing a way to perform specific actions in response to these signals. 
- The program then enters an infinite loop, waiting for signals while continuing its normal execution.


### 5. kill():
- function in C is used to send a signal to a process or a group of processes specified by the process ID.

Syntax:
```
#include <signal.h>

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

Parameters:
pid: 
- The process ID of the target process. It can take the following values:
    - `> 0`: 
      The signal is sent to the process with the specified ID.
    - `0`: 
      The signal is sent to all processes in the process group of the calling process.
    - `-1`: 
      The signal is sent to all processes except for process 1 (init).
    - `< -1`: 
      The signal is sent to all processes in the process group -pid.

sig: 
- The signal number or the signal constant to be sent. 
- It can be one of the predefined signal numbers or signal constants defined in `<signal.h>`.

Return Value:
- The function returns 0 on success and -1 on error and sets errno to show that an error has occurred.

Usage:
- The kill() function is used to send a signal to a process or a group of processes specified by the pid. 
- The sig parameter specifies the signal to be sent, which can be either a signal number or a signal constant.
- By convention, a 0 signal is often used to check the validity of the pid without actually sending a signal.

Example:
```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int signum) 
{
    if (signum == SIGUSR1) 
    {
        printf("Received SIGUSR1 signal.\n");
        // Handle SIGUSR1 signal
    } 
    else if (signum == SIGUSR2) 
    {
        printf("Received SIGUSR2 signal.\n");
        // Handle SIGUSR2 signal
    }
}

int main() 
{
    // Register signal handlers
    signal(SIGUSR1, signal_handler);
    signal(SIGUSR2, signal_handler);

    printf("My process ID: %d\n", getpid());

    // Pause the program, waiting for signals
    while (1) 
    {
        pause();
    }
    return (0);
}
```

In this example:
- The signal_handler() function is defined to handle the SIGUSR1 and SIGUSR2 signals. 
    - It checks which signal was received and performs corresponding actions.
- In the main() function, we register signal handlers for SIGUSR1 and SIGUSR2 using the signal() function.
- We then print the process ID using getpid().
- The program enters an infinite loop using while(1) and waits for signals using the pause() function. 
    - The program will pause execution until a signal is received. 
    - When a signal is received, the corresponding signal_handler() function is called to handle the signal.

- To send SIGUSR1 or SIGUSR2 signals to this program, you can use the kill command from another terminal or by another program"
```
// Terminal 1
$ gcc example.c -o example
$ ./example
My process ID: 1234

// Terminal 2
$ kill -SIGUSR1 1234  // Replace 1234 with the actual process ID
```

- You should see the corresponding messages in Terminal 1 indicating the received signals.


### 6. getpid():
- function in C is used to retrieve the process ID (PID) of the calling process, which is a unique identifier assigned to each running process on the system.

Syntax:
```
#include <unistd.h>

pid_t getpid(void);
```

Parameters:
- does not take any parameters.

Return Value:
- The getpid() function returns the process ID (PID) of the calling process. 
- The PID is of type pid_t, which is usually an integer.

Usage:
- The getpid() function is commonly used to identify a specific process or to perform process-specific operations. 
- It allows programs to distinguish between different processes and perform actions based on their process ID.

Example:
```
#include <stdio.h>
#include <unistd.h>

int main(void) 
{
    pid_t pid = getpid();
    printf("My process ID is %d.\n", pid);
    return (0);
}
```

- In this example, the getpid() function is called to retrieve the process ID of the current process. 
- The process ID is then printed using printf().

Output:
```
My process ID is 12345.
```

- Please note that the process ID is unique for each running process on the system, and it can change every time the program is executed.


### 7. pause():
- function in C is used to suspend the execution of a program until a signal is received.

Syntax:
```
#include <unistd.h>

int pause(void);
```

Parameters:
- does not take any parameters.

Return Value:
- The pause() function returns -1 and sets errno to EINTR if it is interrupted by a signal. 
- Otherwise, it does not return.

Usage:
- The pause() function is typically used in signal handling to wait for a specific signal before proceeding with further execution. 
- It allows a program to pause its execution until a signal handler changes the program flow.

Example:
```
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int signum) 
{
    if (signum == SIGUSR1) 
    {
        printf("Received SIGUSR1 signal.\n");
        // Handle SIGUSR1 signal
    } 
    else if (signum == SIGUSR2) 
    {
        printf("Received SIGUSR2 signal.\n");
        // Handle SIGUSR2 signal
    }
}

int main() 
{
    // Register signal handlers
    signal(SIGUSR1, signal_handler);
    signal(SIGUSR2, signal_handler);

    printf("My process ID: %d\n", getpid());

    // Pause the program, waiting for signals
    pause();
    return (0);
}
```

In this example:
- The signal_handler() function is defined to handle the SIGUSR1 and SIGUSR2 signals. 
    - It checks which signal was received and performs corresponding actions.
- In the main() function, we register signal handlers for SIGUSR1 and SIGUSR2 using the signal() function.
- We then print the process ID using getpid().
- The program enters the pause() function, which will block until a signal is received. 
    - Once a signal is received, the corresponding signal_handler() function is called to handle the signal.


### 8. sleep():
- function in C is used to pause the execution of a program for a specified number of seconds.

Syntax:
```
#include <unistd.h>

unsigned int sleep(unsigned int seconds);
```

Parameters:
seconds: 
- specifies the number of seconds the program should sleep.

Return Value:
- The sleep() function returns the number of seconds remaining if it is interrupted by a signal, or 0 if the specified time has elapsed.

Usage:
- The sleep() function is commonly used to introduce delays in program execution or to wait for a specific duration before proceeding with further execution.
- It allows programs to pause for a specified amount of time, which can be useful for synchronization between processes or implementing timed behavior.

Example:
```
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void signalHandler(int signal) 
{
    printf("Signal %d received.\n", signal);
}

int main(void) 
{
    signal(SIGUSR1, signalHandler);
    signal(SIGUSR2, signalHandler);
    printf("Waiting for signals...\n");

    // Sleep for 3 seconds
    sleep(3);

    printf("Resuming execution.\n");
    return (0);
}
```

In this example:
- The program sets up signal handlers for the SIGUSR1 and SIGUSR2 signals.
- It then waits for signals by using the sleep() function for 3 seconds.
- After the sleep period, if any of the signals are received, the corresponding signal handler is invoked.
- The program resumes execution and prints the "Resuming execution" message.

Output:
```
Waiting for signals...
^CSignal 2 received.
Resuming execution.
```

- During the 3 seconds of sleep, if either SIGUSR1 or SIGUSR2 signals are received, the signal handler will be called and the program will resume execution after the sleep period.


### 9. usleep():
- function in C is used to suspend the execution of a program for a specified number of microseconds.

Syntax:
```
#include <unistd.h>

int usleep(useconds_t useconds);
```

Parameters:
useconds:
- specifies the number of microseconds the program should sleep.

Return Value:
- The usleep() function returns 0 if the execution was successful (execution successfully suspended) or -1 if there was an error.

Usage:
- The usleep() function is commonly used to introduce delays in program execution or to pause the program for a specific duration in microseconds.
- It provides a higher precision delay compared to the sleep() function, which operates in seconds.
- The usleep() function is available in POSIX-compliant systems but is considered obsolete in favor of the nanosleep() function.

Example:
```
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void signalHandler(int signal) 
{
    printf("Signal %d received.\n", signal);
}

int main(void) 
{
    signal(SIGUSR1, signalHandler);
    signal(SIGUSR2, signalHandler);
    printf("Waiting for signals...\n");

    // Sleep for 1 second (1000000 microseconds)
    usleep(1000000);
    
    printf("Resuming execution.\n");
    return (0);
}
```

In this example:
- The program sets up signal handlers for the SIGUSR1 and SIGUSR2 signals.
- It then waits for signals by using the usleep() function to pause the program for 1 second (equivalent to 1000000 microseconds).
- After the sleep period, if any of the signals are received, the corresponding signal handler is invoked.
- The program resumes execution and prints the "Resuming execution" message.

Output:
```
Waiting for signals...
^CSignal 2 received.
Resuming execution.
```

- During the 1-second sleep, if either SIGUSR1 or SIGUSR2 signals are received, the signal handler will be called, and the program will resume execution after the sleep period.


### 10. exit():
- function in C is used to terminate the calling process and return control to the operating system.

Syntax:
```
#include <stdlib.h>

void exit(int status);
```

Parameters:
status:
- represents the exit status of the program.

Return Value:
- does not return a value.

Usage:
- The exit() function is commonly used to terminate a program and return control to the operating system.
- It allows you to specify an exit status to indicate the status of the program execution to the caller or the operating system.
- The exit status is typically used to communicate success or failure of the program execution.

Example:
```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void signalHandler(int signal) 
{
    printf("Signal %d received.\n", signal);
    exit(0); // Terminate the program normally
}

int main(void) 
{
    signal(SIGUSR1, signalHandler);
    signal(SIGUSR2, signalHandler);
    printf("Waiting for signals...\n");
    while (1) 
    {
        // Do some work
    }
    return (0);
}
```

In this example:
- The program sets up signal handlers for the SIGUSR1 and SIGUSR2 signals.
- When either of these signals is received, the corresponding signal handler is invoked, which prints a message and then calls exit(0) to terminate the program normally.
- The while(1) loop represents some ongoing work that the program is doing, and it will be interrupted when a signal is received.

Output:
```
Waiting for signals...
^CSignal 2 received.
```

- During the program execution, if either SIGUSR1 or SIGUSR2 signals are received, the signal handler will be invoked, and the program will terminate normally using exit(0).



## Breaking down the assignment and its concepts

### 1. What does “create a communication program in the form of a client and a server” mean?
- To develop an application that allows communication between two separate entities: a client and a server.
- The client and server will interact with each other using SIGUSR1 and SIGUSR2 UNIX signals.

### 1.1 What is a client?
- A client initiates communication and sends requests.
- In the context of our assignment, the client is responsible for sending a message to the server, requesting it to process the provided string. 
- The client takes two parameters: 
    - the server's PID (Process ID) and 
    - the string to send. 
- After sending the request, the client waits for an acknowledgment from the server.

### 1.2 What is a server?
- A server receives and processes client requests before sending back responses.
- In the context of our assignment, the server would be responsible for receiving messages from clients and processing the provided strings. 
- After processing, the server acknowledges the receipt by sending a signal back to the client. 
- The server should be started first and print its Process ID (PID) after launch.

### 1.3 What is a PID?
- A Process Identifier (PID) is a unique number used to uniquely identify an active process.
- This number may be used as a parameter in various function calls, allowing processes to be manipulated, such as adjusting the process's priority or killing it altogether.
- The current process ID is provided by a getpid() system call. 
    - The process ID of a parent process is obtainable by a getppid() system call. 
- In the context of our assignment, the server will print its PID after it launches. 
    - The client program needs to know the server's PID to send signals to it. 
    - This is why the server's PID is one of the parameters that the client takes. We will input the server's PID when we run the client program.
    - This PID will then be used by the client to communicate with/send signals to the server.
        - This is usually done using the kill() function, which sends a signal to a process. 
        - In the context of our assignment, the signals will be SIGUSR1 and SIGUSR2.
    - The server, upon receiving the signals, will handle them accordingly. 
        - This is usually done by setting up signal handlers using the signal() or sigaction() function.




4. How do we get the client to send the string input to the server?

5. The server, prints the string received from the client, how?

5.1 We need it to print the string quickly.

5.2 The server needs to receive strings from several clients in a row without restarting.
//This means your server should have a loop where it waits for and processes incoming signals. The processing in this case would be printing the received string.

6. What does this mean, “Linux system does NOT queue signals when you already have pending signals of this type”?

7. Bonus: What does this mean, “The server acknowledges every message received by sending back a signal to the client”?

7.1 What does “Unicode characters support” mean for our bonus part?


Tree:

Minitalk/
	Makefile/
	libft/?
	ft_printf/?

	client.exe
	server.exe


WHY ARE WE SENDING BITS?

What is the purpose of sending the bits using signals in the context of our Minitalk program?

So, we have a server and a client. The client wants to send a character (let's say 'A') to the server using signals. 

However recall, signals can only transmit one bit at a time. 

So, the client needs to break down the character into its individual bits and send each bit to the server using signals.

The character 'A' (ASCII value 65) as an example:

Binary representation of 'A': 01000001

The goal is to send each bit (0 or 1) to the server using signals. 

So, we need a function e.g. `send_bits` to achieve this by iterating through the bits of the character and sending a signal (SIGUSR1 or SIGUSR2) to the server based on the value of each bit.

```
Character 'A' (ASCII 65) - Binary: 01000001

  Bit:      0       1       0       0       0       0       0       1
  Signal:   SIGUSR2 SIGUSR1 SIGUSR2 SIGUSR2 SIGUSR2 SIGUSR2 SIGUSR2 SIGUSR1
```

In this example:
- Each column represents a bit of the character.
- The bit's value is shown above it (0 or 1).
- The signal sent to the server is indicated below each bit column. 
- A SIGUSR1 signal is sent for a bit value of 1, and a SIGUSR2 signal is sent for a bit value of 0.

As the `send_bits` function iterates through each bit of the character, it sends the appropriate signals to the server to convey the binary representation of the character. 

The server then interprets these signals to reconstruct the original character.

This process of breaking down characters into individual bits and sending them using signals allows the client and server to communicate using a protocol that's based on the transmission of binary information through the signaling mechanism.


TESTING:

Run the Server:

In one terminal window, run the server by executing the server executable. This will start the server process and display its PID on the terminal:

```
./server
```

Take note of the displayed PID, as you'll need it to run the client.

Run the Client:

In another terminal window, run the client by executing the client executable with the server's PID and the message you want to send. For example:

```
./client <server_pid> "Hello, server!"
```

Observe Output:

The client will send the message to the server using signals. We should see the message being displayed on the server terminal. Depending on our implementation, the message might appear character by character, or it might be displayed all at once.

Repeat Testing:

Test our program with different messages, including special characters and longer messages, to ensure it functions as expected.

Test Bonus Features (if applicable):

Test them in a similar way. Make sure we have the necessary files (client_bonus.c, server_bonus.c, etc.) compiled and ready to execute.

Remember to adjust any necessary parameters, such as the communication speed (using usleep) as needed. 